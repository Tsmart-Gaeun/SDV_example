///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : lit.cpp
/// SOFTWARE COMPONENT NAME           : LIT
/// GENERATED DATE                    : 2025-08-22 08:19:37
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "lit/aa/lit.h"
#include "ara/exec/execution_client.h"
#include <ctime>

namespace eevp {
namespace control {

const eevp::type::String LIT::mAppname = "LIT";
std::atomic_bool LIT::mRunning(false);

// 구독 정보 들어오면 LIT에 전달함
class SubscriptionManagementListener 
    : public eevp::subscription::service::ISubscriptionManagementListener {
public:
    //SubscriptionManagementListener 객체 만들 때 LIT 인스턴스의 포인터를 받아서 내부 멤버 변수 lit 으로 저장하는 것. 이후에 이 포인터를 통해 LIT 메서드를 호출
    explicit SubscriptionManagementListener(LIT* appInstance)
        : lit(appInstance) {}

    // 구독 정보 들어오면 LIT에 넘김
    void notifySubscriptionInfo(const eevp::subscription::type::SubscriptionInfo& info) override
    {
        // LIT 객체의 함수에 구독 정보 전달
        lit->notifySubscriptionInfo(info);
    }

private:
    LIT* lit;  // LIT 애플리케이션 인스턴스에 대한 포인터
};

 
LIT::LIT()
    : mLogger(ara::log::CreateLogger("LIT", "SWC", ara::log::LogLevel::kInfo))
    , mSubscription(false)
    , subscriptionManagementProxyImpl{nullptr}
{
    mLogger.LogInfo() << __func__;
    std::signal(SIGTERM, SignalHandler);
}
 
LIT::~LIT()
{
}

void LIT::SignalHandler(std::int32_t /*signal*/) {
    mRunning = false;
}

 
bool LIT::Initialize()
{
    mLogger.LogVerbose() << "LIT::Initialize";
    
    bool init{true};
    
    m_RPortSoaDms = std::make_shared<lit::aa::port::RPortSoaDms>();
    m_RPortSoaSmartFilm = std::make_shared<lit::aa::port::RPortSoaSmartFilm>();
    m_RPortSubscriptionmanagement = std::make_shared<lit::aa::port::RPortSubscriptionmanagement>();
    
    return init;
}
 
void LIT::Start()
{
    mLogger.LogVerbose() << "LIT::Start";
    mRunning = true;

    m_RPortSoaDms->Start();
    m_RPortSoaSmartFilm->Start();
    m_RPortSubscriptionmanagement->Start();

    getSubscriptionInfo();
    
    // run software component
    Run();
}
 
void LIT::Terminate()
{
    std::lock_guard<std::mutex> lock(mSubscriptionMutex);
    mRunning = false;
    mSubscription = false;
    mSubscriptionCv.notify_all();  // Run 루프 탈출
    mLogger.LogInfo() << "App is terminating.";

    mLogger.LogVerbose() << "LIT::Terminate";
    
    m_RPortSoaDms->Terminate();
    m_RPortSoaSmartFilm->Terminate();
    m_RPortSubscriptionmanagement->Terminate();
}
 
void LIT::Run()
{
    mLogger.LogVerbose() << "LIT::Run";
    
    /*
    m_workers.Async([this] { m_RPortSoaDms->ReceiveEventonDriverNotFocusingCyclic(); });
    m_workers.Async([this] { m_RPortSoaDms->ReceiveEventonDriverNotWakenCyclic(); });
    m_workers.Async([this] { m_RPortSoaDms->ReceiveEventonDriverNotWatchingFrontCyclic(); });
    m_workers.Async([this] { m_RPortSoaDms->ReceiveFieldsoaDmsDeviceNormalCyclic(); });
    m_workers.Async([this] { m_RPortSoaDms->ReceiveFieldsoaDmsDriverStatusCyclic(); });
    m_workers.Async([this] { m_RPortSoaDms->ReceiveFieldsoaDmsStatusCyclic(); });
    m_workers.Async([this] { m_RPortSoaDms->ReceiveFieldsoaDmsSwVersionCyclic(); });
    m_workers.Async([this] { m_RPortSoaSmartFilm->ReceiveFieldsoaFilmAutoCyclic(); });
    m_workers.Async([this] { m_RPortSoaSmartFilm->ReceiveFieldsoaFilmDeviceNormalCyclic(); });
    m_workers.Async([this] { m_RPortSoaSmartFilm->ReceiveFieldsoaFilmOpacitiesCyclic(); });
    m_workers.Async([this] { m_RPortSoaSmartFilm->ReceiveFieldsoaFilmSwVersionCyclic(); });
    m_workers.Async([this] { m_RPortSubscriptionmanagement->ReceiveEventnotifySubscriptionInfoCyclic(); });
    */

    mLogger.LogVerbose() << "Consumer::Run";
    
    // start running
    mRunning = true;

    while (mRunning) {
        std::unique_lock<std::mutex> lock(mSubscriptionMutex);
        
        // 타임아웃 5초마다 깨어나서 상태 확인
        if (!mSubscriptionCv.wait_for(lock, std::chrono::seconds(5),
            [&]() { return mSubscription || !mRunning; })) {
            mLogger.LogInfo() << "Still unsubscribed... waiting.";
            continue;
        }
        if (!mRunning) break; // 종료 신호 받으면 나감

        mLogger.LogInfo() << "App is subscribed. Starting main logic.";

        while(!(m_RPort->RequestDmsStatus() && m_RPort->RequestSmartFilmStatus())){
        m_logger.LogVerbose() << "Dms Status, SmartFilm Status Init FAILED";
        std::this_thread::sleep_for(std::chrono::seconds(1));
        }

        lotte::type::SideTransparency initSideTransparency = (m_RPort->RequestSmartFilmCurr(2));
        initTransparency = initSideTransparency.currTransparency;
        lotte::type::SideTransparency driverSideTransparency = { false, 2, initTransparency,initTransparency,0};
        lotte::type::SideTransparency passengerSideTransparency = { false, 2, initTransparency,initTransparency,0};
        lotte::type::SideTransparency backMirrorSideTransparency = { false, 2, initTransparency,initTransparency,0};

        while (mSubscription && mRunning)
        {
            lotte::type::DmsGzDtctn dmsGzDtctn = (m_RPort->RequestDmsCurr());
            // m_logger.LogVerbose() << "GazeZone : " << dmsGzDtctn.gazeZoneToString();
            switch (dmsGzDtctn.gazeZone) {
                case lotte::type::GazaZone::FRONT_WINDSHIELD :
                    driverSideTransparency.remainingTime -= 10;
                    passengerSideTransparency.remainingTime -= 10;
                    backMirrorSideTransparency.remainingTime -= 10;
                    mLogger.LogVerbose() << "EYES ON FRONT_WINDSHIELD";
                    break;
                case lotte::type::GazaZone::DRIVER_SIDE_MIRROR :
                    if(driverSideTransparency.isChanged){
                        driverSideTransparency.remainingTime = 10000;
                    }else{
                        m_RPort->RequestSmartFilmControl(2, 100);
                        driverSideTransparency.remainingTime = 10000;
                        driverSideTransparency.isChanged = true;
                        driverSideTransparency.currTransparency = 100;
                    }
                    passengerSideTransparency.remainingTime -= 10;
                    backMirrorSideTransparency.remainingTime -= 10;
                    mLogger.LogVerbose() << "EYES ON DRIVER_SIDE_MIRROR";
                    break;
                case lotte::type::GazaZone::PASSENGER_SIDE_MIRROR :
                    m_RPort->RequestSmartFilmControl(3, 100);
                    driverSideTransparency.remainingTime -= 10;
                    if(passengerSideTransparency.isChanged){
                        passengerSideTransparency.remainingTime = 10000;
                    }else{
                        m_RPort->RequestSmartFilmControl(3, 100);
                        passengerSideTransparency.remainingTime = 10000;
                        passengerSideTransparency.isChanged = true;
                        passengerSideTransparency.currTransparency = 100;
                    }
                    backMirrorSideTransparency.remainingTime -= 10;
                    mLogger.LogVerbose() << "EYES ON PASSENGER_SIDE_MIRROR";
                    break;
                case lotte::type::GazaZone::BACK_MIRROR :
                    m_RPort->RequestSmartFilmControl(4, 100);
                    driverSideTransparency.remainingTime -= 10;
                    passengerSideTransparency.remainingTime -= 10;
                    if(backMirrorSideTransparency.isChanged){
                        backMirrorSideTransparency.remainingTime = 10000;
                    }else{
                        m_RPort->RequestSmartFilmControl(4, 100);
                        backMirrorSideTransparency.remainingTime = 10000;
                        backMirrorSideTransparency.isChanged = true;
                        backMirrorSideTransparency.currTransparency = 100;
                    }
                    mLogger.LogVerbose() << "EYES ON BACK_MIRROR";
                    break;
                default:
                    // m_logger.LogVerbose() << "GAZE ZONE DEFAULT : " << dmsGzDtctn.gazeZoneToString();
                    break;
            }
            if(driverSideTransparency.remainingTime <= 0){
                m_RPort->RequestSmartFilmControl(2, initTransparency);
                driverSideTransparency.currTransparency = initTransparency;
                driverSideTransparency.remainingTime = 0;
                driverSideTransparency.isChanged = false;
            }
            if(passengerSideTransparency.remainingTime <= 0){
                m_RPort->RequestSmartFilmControl(3, initTransparency);
                passengerSideTransparency.currTransparency = initTransparency;
                passengerSideTransparency.remainingTime = 0;
                passengerSideTransparency.isChanged = false;
            }
            if(backMirrorSideTransparency.remainingTime <= 0){
                m_RPort->RequestSmartFilmControl(4, initTransparency);
                backMirrorSideTransparency.currTransparency = initTransparency;
                backMirrorSideTransparency.remainingTime = 0;
                backMirrorSideTransparency.isChanged = false;
            }
            // m_logger.LogInfo() << "DRIVER : " << driverSideTransparency.currTransparency << ", PASSENGER : " << passengerSideTransparency.currTransparency
            // << "BACK MIRROR : " << backMirrorSideTransparency.currTransparency;
            
            std::this_thread::sleep_for(std::chrono::milliseconds(10));

            // 중간에 구독이 끊기면 break
            if (!mSubscription) {
                mLogger.LogInfo() << "App is unsubscribed. Pausing logic.";
                break;
            }
        }            
    }

    m_workers.Wait();

}

bool LIT::startSubscriptionManagementProxy() {
    mLogger.LogInfo() << __func__;
    subscriptionManagementProxyImpl = std::make_shared<eevp::subscription::service::SubscriptionManagementProxyImpl>();
    auto subscriptionManagementListener = std::make_shared<SubscriptionManagementListener>(this);
    subscriptionManagementProxyImpl->setEventListener(subscriptionManagementListener);
    subscriptionManagementProxyImpl->init();
    return true;
}

 
} /// namespace aa
} /// namespace lit
